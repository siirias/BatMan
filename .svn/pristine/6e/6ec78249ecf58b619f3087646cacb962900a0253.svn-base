#include "BathyData.h"


BathyData::BathyData()
{
	x_in_m = 2000.0f;
	y_in_m = 2000.0f;
	depth_in_m = 1.0f;
	depth_negative = false;
}


BathyData::~BathyData()
{
}

bool BathyData::LoadFromFile(std::string FileName, irr::IrrlichtDevice *device)
{
	if (LoadFromXMLFile(FileName,device))
	{
		std::cout << "XML metadata read succesfully.\n";
		return true;
	}
	//If XML reading didn't succeed, then let's try to read as regular ascii file.
	reset_metadata();
	std::cout << "No recognizable xml data, trying as pure ascii\n";
	depths.clear();
	std::fstream fp;
	fp.open(FileName, std::ios::in);
	cell_sizes.clear();
	unsigned int x = 0;
	unsigned int y = 0;
	if (fp.is_open())
	{
		float number;
		std::string tmp;
		while (std::getline(fp, tmp, '\n'))
		{
			y = 0;
			std::string tmp2;
			std::istringstream iss(tmp);
			while (std::getline(iss, tmp2, ' '))
			{
				number = (float)atof(tmp2.c_str());
				if (!depth_negative)
					number *= -1.0f;
				if (number > 0.0f)
					number = 0.0f;
				depths.push_back(number);
				y++;
				cell_sizes.setX(bm_max(cell_sizes.getX(), x));
				cell_sizes.setY(bm_max(cell_sizes.getY(), y));
			}
			x++;
		}
		std::cout << "Ascii data  read succesfully.\n";
	}
	else
		return false;
	fp.close();
	return true;
}

bool BathyData::LoadFromXMLFile(std::string FileName, irr::IrrlichtDevice *device)
{
	if (device == NULL)
		return false;
	irr::io::IXMLReader *xml = device->getFileSystem()->createXMLReader(irr::core::stringw(FileName.c_str()).c_str());
	if (!xml)
	{
		return false;
	}
	bool got_data = false;
	irr::core::stringw current_block = L"";
	while (xml->read())
	{
		switch (xml->getNodeType())
		{
			case irr::io::EXN_ELEMENT:
			{
				if (((irr::core::stringw) xml->getNodeName()).equals_ignore_case("depth_negative"))
				{
					depth_negative = xml->getAttributeValueAsInt(0)!=0;
				}
				if (((irr::core::stringw) xml->getNodeName()).equals_ignore_case("data"))
				{
					current_block = ((irr::core::stringw) xml->getNodeName());
				}
			}
			break;
			case irr::io::EXN_TEXT:
			{
				if (current_block.equals_ignore_case("data"))
				{
					std::istringstream data(wchar2str(xml->getNodeData()));
					depths.clear();
					cell_sizes.clear();
					unsigned int x = 0;
					unsigned int y = 0;
					float number;
					std::string tmp;
					while (std::getline(data, tmp, '\n'))
					{
						if (strspn(tmp.c_str(), "-.0123456789") == 0)
							continue; //No numbers in this line so skip
						y = 0;
						x++;
						std::string tmp2;
						std::istringstream iss(tmp);
						while (std::getline(iss, tmp2, ' '))
						{
							if (strspn(tmp2.c_str(), "-.0123456789") != tmp2.size())
								continue; //This is no number
							number = (float)atof(tmp2.c_str());
							if (!depth_negative)
								number *= -1.0f;
							if (number > 0.0f)
								number = 0.0f;
							depths.push_back(number);
							y++;
							cell_sizes.setX(bm_max(cell_sizes.getX(), x));
							cell_sizes.setY(bm_max(cell_sizes.getY(), y));
						}
					}
				}
				got_data = true;
			}
			break;
			case irr::io::EXN_ELEMENT_END:
			{
				current_block = "";
			}
			break;
		}
	}
	xml->drop();
	return got_data;
}

bool BathyData::SaveToXMLFile(std::string FileName, irr::IrrlichtDevice * device)
{
	bool success = true;
	if (device == NULL)
		return false;
	irr::io::IXMLWriter* xwriter = device->getFileSystem()->createXMLWriter(irr::core::stringw(FileName.c_str()).c_str());
	if (!xwriter)
	{
		return false;
	}
	xwriter->writeXMLHeader();
	wchar_t tmp[100];
	swprintf(tmp,100,L"%d",depth_negative);
	xwriter->writeElement(L"depth_negative", true, L"dn",tmp);
	xwriter->writeLineBreak();                  //new line
	xwriter->writeElement(L"Data");
	xwriter->writeLineBreak();                  //new line
	for (unsigned int x = 0;x< cell_sizes.getX(); x++)
	{
		for (unsigned int y = 0; y< cell_sizes.getY(); y++)
		{
			float depth = depths[y+x*cell_sizes.getY()];
			if (!depth_negative)
				depth *= -1.0f;
			wchar_t tmp[20];
			swprintf(tmp, 20, L"%f ", depth);
			xwriter->writeText(tmp);
		}
		xwriter->writeLineBreak();                  //new line
	}
	//unsigned int x = 0;
	//unsigned int y = 0;
	//float number;
	//std::string tmp;
	//while (std::getline(data, tmp, '\n'))
	//{
	//	y = 0;
	//	std::string tmp2;
	//	std::istringstream iss(tmp);
	//	while (std::getline(iss, tmp2, ' '))
	//	{
	//		number = (float)atof(tmp2.c_str());
	//		if (!depth_negative)
	//			number *= -1.0f;
	//		if (number > 0.0f)
	//			number = 0.0f;
	//		depths.push_back(number);
	//		y++;
	//		cell_sizes.setX(bm_max(cell_sizes.getX(), x));
	//		cell_sizes.setY(bm_max(cell_sizes.getY(), y));
	//	}
	//	x++;
	//}


	xwriter->writeClosingTag(L"Data");
	xwriter->writeLineBreak();                  //new line
	//delete xml writer
	xwriter->drop();
	return success;
}


bool BathyData::CreateEmpty(int X_cells, int Y_cells)
{
	depths.clear();
	cell_sizes.clear();
	cell_sizes.setX(X_cells);
	cell_sizes.setY(Y_cells);
	depths.clear();
	depths.resize(X_cells*Y_cells, 0.0f);
	return true;
}

void BathyData::reset_metadata()
{
	depth_negative = false;
}

void BathyData::AddRandomNoise(float delta)
{
	for (long i = 0; i < depths.size(); i++)
	{
		if (depths[i] < 0.0f)
		{
			depths[i] = bm_min(0,depths[i]+delta*(1.0f-2.0f*bm_rnd()));
		}
	}
}

int BathyData::ChangeHeight(int cell_no, int range, float amount)
{
	return ChangeHeight(cell_no/cell_sizes.getY(), cell_no%cell_sizes.getY(),range,amount);
}

int BathyData::ChangeHeight(int x, int y, int range,float amount)
{
	if(x+range <0 || x-range > (signed int)cell_sizes.getX()-1 || y+range<0 || y-range>(signed int)cell_sizes.getY()-1)
		return 0; //No point is in the range of modification
	int modified = 0;
	for (int x_i = bm_max(0, x - range); x_i <(bm_min((signed int)cell_sizes.getX(),x + range)); x_i++)
	{
		for (int y_i = bm_max(0, y - range); y_i < (bm_min((signed int)cell_sizes.getY(), y + range)); y_i++)
		{
			float dist2 =(float)( pow(x_i - x, 2) + pow(y_i - y, 2));
			if (dist2 < range*range)
			{
				depths[x_i*cell_sizes.getY() + y_i] += amount*(1.0f-(((float)sqrt(dist2))/((float)range)));
				depths[x_i*cell_sizes.getY() + y_i] = bm_min(0.0f, depths[x_i*cell_sizes.getY() + y_i]);
				modified++;
			}
		}
	}
	return modified;
}
