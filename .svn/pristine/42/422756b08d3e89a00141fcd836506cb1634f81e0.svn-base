#include "Receiver.h"

Receiver::Receiver(SAppContext & context) : Context(context)
{ 
	wire = true; 
	smooth = false;
	take_screenshot=false;
	quitting=false;
	depth_scale = 1.0f;
	depth_scale_updated = false;
	mouse_x_old=mouse_x = -1;
	mouse_y_old = mouse_y = -1;
	cam_pos_move = NULL_VEC;
	cam_rot_move = NULL_VEC;
	cam_dist_move = 0.0f;
	gui_activated = false;
	selected_filename = "";
	selected_directory = "";
	change_mode_to = -1;
	ui_order = BM_UI_ORDER_NONE;
	last_menu_selection = GUI_ID_NONE;
}


Receiver::~Receiver()
{
}

void Receiver::setSkinTransparency(s32 alpha, irr::gui::IGUISkin * skin)
{
	for (s32 i = 0; i<irr::gui::EGDC_COUNT; ++i)
	{
		video::SColor col = skin->getColor((EGUI_DEFAULT_COLOR)i);
		col.setAlpha(alpha);
		skin->setColor((EGUI_DEFAULT_COLOR)i, col);
	}
}

bool Receiver::OnEvent(const SEvent& event)
{
	bool activate_toggle_grid = false;
	bool activate_toggle_smooth = false;
	if (event.EventType == EET_KEY_INPUT_EVENT )
	{
		if (event.KeyInput.PressedDown)
		{
			switch (event.KeyInput.Key)
			{
			case KEY_KEY_G:
				activate_toggle_grid = true;
				break;
			case KEY_KEY_S:
				activate_toggle_smooth = true;
				break;
			case KEY_KEY_R:
				ui_order = BM_UI_ORDER_RESET_VIEW;
				break;
			case KEY_PLUS:
				ui_order = BM_UI_ORDER_RAISE_POINT;
				break;
			case KEY_MINUS:
				ui_order = BM_UI_ORDER_LOWER_POINT;
				break;

			}
		}
		
	}
	if (event.EventType == EET_GUI_EVENT)
	{
		gui_activated = true;
		if (Context.device == NULL)
			return false;
		s32 id = event.GUIEvent.Caller->getID();
		IGUIEnvironment* env = Context.device->getGUIEnvironment();

		switch (event.GUIEvent.EventType)
		{

		case EGET_SCROLL_BAR_CHANGED:
			if (id == GUI_ID_TRANSPARENCY_SCROLL_BAR)
			{
				s32 pos = ((IGUIScrollBar*)event.GUIEvent.Caller)->getPos();
				setSkinTransparency(pos, env->getSkin());
			}
			if (id == GUI_ID_DEPTH_SCROLL_BAR)
			{
				s32 pos = ((IGUIScrollBar*)event.GUIEvent.Caller)->getPos();
				//let's say 1.0 is in the middle:
				float position = ((float)pos / bm_default_slider_steps);
				if(position>0.5f)
					depth_scale = (2.0f*(position-0.5f))*(bm_max_depth_scale-1.0f) + 1.0f;
				else
					depth_scale = (2.0f*(position))*(1.0f-bm_min_depth_scale) + bm_min_depth_scale;

				depth_scale_updated = true;
			}
			break;

		case EGET_BUTTON_CLICKED:
			switch (id)
			{
			case GUI_ID_QUIT_BUTTON:
				Context.device->closeDevice();
				quitting = true;
				break;
			case GUI_ID_BATY_WIRE:
				activate_toggle_grid = true;
				break;
			case GUI_ID_BATY_SMOOTH:
				activate_toggle_smooth = true;
				break;
			case GUI_ID_SCREENSHOT:
				take_screenshot = true;
				break;

			default:
				break;
			}
			break;

		case EGET_MENU_ITEM_SELECTED:
		{
			irr::gui::IGUIContextMenu *active_menu = (IGUIContextMenu*)event.GUIEvent.Caller;
			if (active_menu == NULL)
				break;
			switch (id)
			{
				case GUI_ID_FILEMENU:
				{
					if (active_menu->getItemCommandId(active_menu->getSelectedItem())==GUI_ID_QUIT_BUTTON)
					{
						Context.device->closeDevice();
						quitting = true;
					}
					if (active_menu->getItemCommandId(active_menu->getSelectedItem()) == GUI_ID_LOAD_BATHY)
					{
						IGUIFileOpenDialog *fod = env->addFileOpenDialog(L"Open a bathymetry file",true);
						if (fod != NULL)
						{
							change_mode_to = BM_MODE_MENUS;
							last_menu_selection = GUI_ID_LOAD_BATHY;
						}
					}
					if (active_menu->getItemCommandId(active_menu->getSelectedItem()) == GUI_ID_SAVE_AS_BATHY)
					{
						IGUIFileOpenDialog *fod = env->addFileOpenDialog(L"Save bathymetry file as",true);
						if (fod != NULL)
						{
							change_mode_to = BM_MODE_MENUS;
							last_menu_selection = GUI_ID_SAVE_AS_BATHY;
						}
					}
					if (active_menu->getItemCommandId(active_menu->getSelectedItem()) == GUI_ID_NEW_BATHY)
					{
						ui_order = BM_UI_ORDER_NEW_FILE;
					}
					break;
				}
				case GUI_ID_VIEWMENU:
				{
					if (active_menu->getItemCommandId(active_menu->getSelectedItem()) == GUI_ID_BATY_WIRE)
						activate_toggle_grid=true;
					if (active_menu->getItemCommandId(active_menu->getSelectedItem()) == GUI_ID_BATY_SMOOTH)
						activate_toggle_smooth=true;
					break;
				}
			}
			break;
		}
		case EGET_FILE_SELECTED:
		{
			// show the model filename, selected in the file dialog
			IGUIFileOpenDialog* dialog =(IGUIFileOpenDialog*)event.GUIEvent.Caller;
			selected_filename=wchar2str((wchar_t*)dialog->getFileName());
			change_mode_to = BM_MODE_EDIT;
			if(last_menu_selection==GUI_ID_LOAD_BATHY)
				ui_order = BM_UI_ORDER_LOAD_FILE;
			if (last_menu_selection == GUI_ID_SAVE_AS_BATHY)
				ui_order = BM_UI_ORDER_SAVE_AS_FILE;
		}
		break;

		default:
			break;
		}
	}

	if (event.EventType == EET_MOUSE_INPUT_EVENT)
	{
		switch (event.MouseInput.Event)
		{
			case EMIE_MOUSE_MOVED:
			{
				mouse_x_old = mouse_x;
				mouse_y_old = mouse_y;
				mouse_x = event.MouseInput.X;
				mouse_y = event.MouseInput.Y;
				int diff_x = mouse_x_old - event.MouseInput.X;
				int diff_y = mouse_y_old - event.MouseInput.Y;
				if (event.MouseInput.isRightPressed())
				{
					if (mouse_x_old > 0 && mouse_y_old > 0) //Move only if these are initilaized
					{
						cam_pos_move = irr::core::vector3df((float)diff_x, -1.0f*(float)diff_y, 0.0f);
					}
				}
				if (event.MouseInput.isLeftPressed())
				{
					if (mouse_x_old > 0 && mouse_y_old > 0) //Move only if these are initilaized
					{
						//cam_rot_move.Y = (float)diff_x;
						cam_rot_move.X = -1.0f*(float)diff_y;
					}
				}
				if (event.MouseInput.isMiddlePressed())
				{
					if (mouse_x_old > 0 && mouse_y_old > 0) //Move only if these are initilaized
					{
						cam_rot_move.Z = (float)diff_x;
					}
				}
				break;
			}
			case EMIE_MOUSE_WHEEL:
			{
				if (mouse_x_old > 0 && mouse_y_old > 0) //Move only if these are initilaized
				{
					cam_dist_move = -3.0f*event.MouseInput.Wheel;
				}
				break;
			}
		}
	}
	if (activate_toggle_grid)
		wire = !wire;
	if (activate_toggle_smooth)
		smooth ? smooth = false : smooth = true;
	return false;
}


