#include "BMApp.h"



BMApp::BMApp()
{
	active_mode = BM_MODE_EDIT;
	main_bm_node = NULL;
	main_cam = NULL;
	cam_distance_from_surface = 50.0f;
	cam_rotation = NULL_VEC;
	GF.device = NULL;
	lights.clear();
}


BMApp::~BMApp()
{
	clear();
}

bool BMApp::init()
{
	GF.Init();
	if (GF.device == 0)
		return false; // could not create selected driver.
	GF.SetMenu();
	main_bm_node = new BathyGraph(GF.smgr->getRootSceneNode(), GF.smgr, 666);// , x, y, depths);
	if (main_bm_node != NULL)
	{
		main_bm_node->Bathymetry.LoadFromFile("v2_domain0.txt",GF.device);
		main_bm_node->RefreshFromData();
	}
	else
		return false;
	GF.smgr->setAmbientLight(video::SColorf(0.5f, 0.5f, 0.5f, 0.5f));
	lights.push_back(GF.smgr->addLightSceneNode(0, core::vector3df(60, 60, -200.0f), video::SColorf(0.2f, 0.2f, 0.2f), 200.0f, 1));
	//main_bm_node->setRotation(core::vector3df(-90.0f, -90.0, 90.0));
	if (main_cam != NULL)
	{
		main_cam->drop();
		main_cam = NULL;
	}
//	main_cam = GF.smgr->addCameraSceneNodeMaya();
	main_cam = GF.smgr->addCameraSceneNode();
	if (main_cam)
	{
		main_cam->setPosition(main_bm_node->getPosition()+irr::core::vector3df(0.0f,0.0f,-50.0f));
		main_cam->setTarget(main_bm_node->getPosition());
	}
	return true;
}

bool BMApp::refresh_app()
{
	if (GF.device == NULL || GF.receiver==NULL)
		return false;
	GF.device->run();
	if (GF.device->isWindowActive() && main_cam != NULL && GF.receiver!=NULL)
	{
		if (GF.receiver->gui_activated)
		{
			GF.receiver->cam_dist_move = 0.0f;
			GF.receiver->cam_pos_move = NULL_VEC;
			GF.receiver->cam_rot_move = NULL_VEC;
		}
		handle_inputs();
		update_cam();
		GF.receiver->gui_activated = false;
		if (lights.size()>0)
			lights[0]->setPosition(main_cam->getTarget()+irr::core::vector3df(0.0f,0.0f,-50.0f));
		GF.driver->beginScene(true, true, SColor(0, 128, 128, 128));

		GF.smgr->drawAll();
		GF.env->drawAll();
		GF.driver->setTransform(ETS_WORLD,IdentityMatrix);
//		bm_intvec selected_cell=main_bm_node->index_from_world_coord(main_cam->getTarget());
//		vector3df selected_spot= main_bm_node->world_coord_from_index(selected_cell);
		bm_intvec selected_cell = main_bm_node->index_from_world_coord(cursor_location);
		vector3df cursor_choice = main_bm_node->world_coord_from_index(selected_cell);

		//GF.driver->draw3DLine(vector3df(selected_spot.X, selected_spot.Y, selected_spot.Z + 100.0f),
		//	vector3df(selected_spot.X, selected_spot.Y, selected_spot.Z - 10.0f),
		//	SColor(255, 255, 255, 255));
		GF.driver->draw3DLine(vector3df(cursor_choice.X, cursor_choice.Y, 100.0f),
			vector3df(cursor_choice.X, cursor_choice.Y, - 1.0f),
			SColor(255, 255, 0, 0));
		int cell_num = selected_cell.Y + selected_cell.X*main_bm_node->cells_y;
		if (cell_num >= 0 && cell_num < main_bm_node->cells)
		{
			stringw tmp_txt;
			char tmp_ch[40];
			sprintf(tmp_ch, "Depth: %3.1f m", main_bm_node->Bathymetry.depths[cell_num]);
			tmp_txt =tmp_ch;
			core::dimension2d<u32> screen_dim= GF.driver->getScreenSize();
			GF.font->draw(tmp_txt, rect<s32>(screen_dim.Width-100, 0, screen_dim.Width, 20), SColor(255, 0,0,0));
		}

		GF.driver->endScene();
		if (GF.receiver->take_screenshot)
		{
			save_screenshot();
		}
	}
	return false;
}

int BMApp::handle_inputs()
{
	if (GF.receiver == NULL)
		return false;
	main_bm_node->wire = GF.receiver->wire;
	main_bm_node->smooth = GF.receiver->smooth;
	if (GF.receiver->change_mode_to != -1)
	{
		active_mode = GF.receiver->change_mode_to;
		GF.receiver->change_mode_to = -1;
	}
	if (active_mode == BM_MODE_EDIT)
	{
		//JUST A TEST FOR MOUSE DETECTION. DO NICER VERSION!
		ISceneCollisionManager *colmgr = GF.smgr->getSceneCollisionManager();
		line3d<f32> raytrace = colmgr->getRayFromScreenCoordinates(GF.device->getCursorControl()->getPosition(), main_cam);
		if (fabs(raytrace.end.Z - raytrace.start.Z) != 0.0f)
		{
			float ratio = fabs(raytrace.start.Z) / fabs(raytrace.end.Z - raytrace.start.Z);
			cursor_location.X = (raytrace.start.X + (raytrace.end.X - raytrace.start.X)*ratio);
			cursor_location.Y = (raytrace.start.Y + (raytrace.end.Y - raytrace.start.Y)*ratio);
			cursor_location.Z = (raytrace.start.Z + (raytrace.end.Z - raytrace.start.Z)*ratio);
		}
		if (GF.receiver->depth_scale_updated)
		{
			if (main_bm_node != NULL)
				main_bm_node->setScale(vector3df(1.0f, 1.0f, GF.receiver->depth_scale));
			GF.receiver->depth_scale_updated = false;
		}
		if (GF.receiver->cam_pos_move != NULL_VEC && main_cam != NULL)
		{
			//main_cam->setPosition(main_cam->getPosition()+GF.receiver->cam_pos_move);
			GF.receiver->cam_pos_move.rotateXYBy(cam_rotation.Z);
			GF.receiver->cam_pos_move = GF.receiver->cam_pos_move*(cam_distance_from_surface/400.0f);
			main_cam->setTarget(main_cam->getTarget() + GF.receiver->cam_pos_move);
			GF.receiver->cam_pos_move = NULL_VEC;
		}
		if (GF.receiver->cam_rot_move != NULL_VEC && main_cam != NULL)
		{
			cam_rotation += GF.receiver->cam_rot_move;
			GF.receiver->cam_rot_move = NULL_VEC;
		}
		if (GF.receiver->cam_dist_move != 0.0f && main_cam != NULL)
		{
			cam_distance_from_surface += GF.receiver->cam_dist_move;
			cam_distance_from_surface = bm_max(10.0f, cam_distance_from_surface);
			cam_distance_from_surface = bm_min(400.0f, cam_distance_from_surface);
			GF.receiver->cam_dist_move = 0.0f;
		}

		//NEW ORDERS:
		if (GF.receiver->ui_order != BM_UI_ORDER_NONE)
		{
			switch (GF.receiver->ui_order)
			{
			case BM_UI_ORDER_NEW_FILE:
				main_bm_node->Bathymetry.CreateEmpty(100,100);
				main_bm_node->ClearGraphicalData();
				main_bm_node->RefreshFromData();
				if (main_bm_node != NULL)
					main_bm_node->setScale(vector3df(1.0f, 1.0f, GF.receiver->depth_scale));
				break;
			case BM_UI_ORDER_LOAD_FILE:
				main_bm_node->Bathymetry.LoadFromFile(GF.receiver->selected_filename,GF.device);
				main_bm_node->ClearGraphicalData();
				main_bm_node->RefreshFromData();
				if (main_bm_node != NULL)
					main_bm_node->setScale(vector3df(1.0f, 1.0f, GF.receiver->depth_scale));
				break;
			case BM_UI_ORDER_RESET_VIEW:
				cam_rotation = NULL_VEC;
//				if(main_cam!=NULL)
//					main_cam->setTarget(NULL_VEC);
				break;
			}
			GF.receiver->ui_order = BM_UI_ORDER_NONE;
		}
	}
	return true;
}

bool BMApp::update_cam()
{
	irr::core::vector3df cam_modif = NULL_VEC;
	cam_modif += irr::core::vector3df(0.0f,0.0f,-1.0f*cam_distance_from_surface);
	cam_rotation.X = bm_min(bm_max(-85.0f, cam_rotation.X), -1.0f);
	cam_rotation.Y = bm_min(bm_max(-80, cam_rotation.Y), 80.0f);
	cam_modif.rotateYZBy(cam_rotation.X);
	cam_modif.rotateXZBy(cam_rotation.Y);
	cam_modif.rotateXYBy(cam_rotation.Z);
	main_cam->setPosition(main_cam->getTarget()+cam_modif);
	main_cam->setUpVector(vector3df(0.0f, 0.0f,-1.0f));
	return false;
}

bool BMApp::save_screenshot()
{
	irr::video::IImage* const image = GF.driver->createScreenShot();
	if (image) //should always be true, but you never know. ;)
	{
		//construct a filename, consisting of local time and file extension
		irr::c8 filename[64];
		snprintf(filename, 64, "screenshot_%u.png", GF.device->getTimer()->getRealTime());

		//write screenshot to file
		if (!GF.driver->writeImageToFile(image, filename))
			GF.device->getLogger()->log(L"Failed to take screenshot.", irr::ELL_WARNING);

		//Don't forget to drop image since we don't need it anymore.
		image->drop();
	}
	GF.receiver->take_screenshot = false;
	return true;
}

bool BMApp::clear()
{
	if (GF.device != NULL)
	{
		GF.device->drop();
		GF.device = NULL;
	}
	std::vector<ILightSceneNode*>::iterator i;
	for (i = lights.begin(); i != lights.end(); i++)
	{
		(*i) = NULL;
	}
	lights.clear();
	return true;
}
